package uspv

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/lightningnetwork/lnd/elkrem"

	"github.com/btcsuite/fastsha256"
	"github.com/roasbeef/btcd/btcec"
	"github.com/roasbeef/btcd/txscript"
	"github.com/roasbeef/btcd/wire"
	"github.com/roasbeef/btcutil"
	"github.com/roasbeef/btcutil/txsort"
)

const (
	// high 3 bytes are in sequence, low 3 bytes are in time
	seqMask  = 0xff000000 // assert high byte
	timeMask = 0x21000000 // 1987 to 1988

	MSGID_CHANDESC = 0x32
	MSGID_CHANACK  = 0x33
	MSGID_SIGPROOF = 0x34

	MSGID_CLOSEREQ  = 0x40
	MSGID_CLOSERESP = 0x41

	MSGID_TEXTCHAT = 0x70

	MSGID_RTS    = 0x80 // pushing funds in channel; request to send
	MSGID_ACKSIG = 0x81 // pulling funds in channel; acknowledge update and sign
	MSGID_SIGREV = 0x82 // pushing funds; signing new state and revoking old
	MSGID_REVOKE = 0x83 // pulling funds; revoking previous channel state

	MSGID_FWDMSG     = 0x20
	MSGID_FWDAUTHREQ = 0x21
)

// Uhh, quick channel.  For now.  Once you get greater spire it upgrades to
// a full channel that can do everything.
type Qchan struct {
	// S for stored (on disk), D for derived

	Utxo                 // S underlying utxo data
	CloseData QCloseData // S closing outpoint

	ChannelNonce [20]byte // S made by funder; stored by both
	MyPub        [33]byte // D my channel specific pubkey
	TheirPub     [33]byte // D their channel specific pubkey

	PeerIdx uint32   // D local unique index of peer.  derived from place in db.
	PeerId  [33]byte // D useful for quick traverse of db

	TheirRefundPub [33]byte // S their pubkey for channel break
	MyRefundPub    [33]byte // D my refund pubkey for channel break

	// Elkrem is used for revoking state commitments
	ElkSnd *elkrem.ElkremSender   // D derived from channel specific key
	ElkRcv *elkrem.ElkremReceiver // S stored in db

	TimeOut uint16   // blocks for timeout (default 5 for testing)
	State   *StatCom // S state of channel
}

// StatComs are State Commitments.
// all elements are saved to the db.
type StatCom struct {
	StateIdx uint64 // this is the n'th state commitment

	MyAmt int64 // my channel allocation
	// their Amt is the utxo.Value minus this
	Delta int32 // fun amount in-transit; is negative for the pusher

	// Homomorphic Adversarial Key Derivation public keys (HAKD)
	MyHAKDPub     [33]byte // saved to disk
	MyPrevHAKDPub [33]byte // When you haven't gotten their revocation elkrem yet.

	sig []byte // Counterparty's signature (for StatCom tx)
	// don't write to sig directly; only overwrite via

	// note sig can be nil during channel creation. if stateIdx isn't 0,
	// sig should have a sig.
	// only one sig is ever stored, to prevent broadcasting the wrong tx.
	// could add a mutex here... maybe will later.
}

// QCloseData is the output resulting from an un-cooperative close
// of the channel.  This happens when either party breaks non-cooperatively.
// It describes "your" output, either pkh or time-delay script.
// If you have pkh but can grab the other output, "grabbable" is set to true.
// This can be serialized in a separate bucket

type QCloseData struct {
	// 3 txid / height pairs are stored.  All 3 only are used in the
	// case where you grab their invalid close.
	CloseTxid   wire.ShaHash
	CloseHeight int32
	Closed      bool // if channel is closed; if CloseTxid != -1
}

// GetStateIdxFromTx returns the state index from a commitment transaction.
// No errors; returns 0 if there is no retrievable index.
func GetStateIdxFromTx(tx *wire.MsgTx) uint64 {
	// no tx, so no index
	if tx == nil {
		return 0
	}
	// more than 1 input, so not a close tx
	if len(tx.TxIn) != 1 {
		return 0
	}
	// check that indicating high bytes are correct
	if tx.TxIn[0].Sequence>>24 != 0xff || tx.LockTime>>24 != 0x21 {
		//		fmt.Printf("sequence byte %x, locktime byte %x\n",
		//			tx.TxIn[0].Sequence>>24, tx.LockTime>>24 != 0x21)
		return 0
	}
	// high 24 bits sequence, low 24 bits locktime
	seqBits := uint64(tx.TxIn[0].Sequence & 0x00ffffff)
	timeBits := uint64(tx.LockTime & 0x00ffffff)

	return seqBits<<24 | timeBits
}

// SetStateIdxBits modifies the tx in place, setting the sequence and locktime
// fields to indicate the given state index.
func SetStateIdxBits(tx *wire.MsgTx, idx uint64) error {
	if tx == nil {
		return fmt.Errorf("SetStateIdxBits: nil tx")
	}
	if len(tx.TxIn) != 1 {
		return fmt.Errorf("SetStateIdxBits: tx has %d inputs", len(tx.TxIn))
	}
	if idx >= 1<<48 {
		return fmt.Errorf(
			"SetStateIdxBits: index %d greater than max %d", idx, uint64(1<<48)-1)
	}

	// high 24 bits sequence, low 24 bits locktime
	seqBits := uint32(idx >> 24)
	timeBits := uint32(idx & 0x00ffffff)

	tx.TxIn[0].Sequence = seqBits | seqMask
	tx.LockTime = timeBits | timeMask

	return nil
}

// GetCloseTxos takes in a tx and sets the QcloseTXO feilds based on the tx.
// It also returns the spendable (u)txos generated by the close.
func (q *Qchan) GetCloseTxos(tx *wire.MsgTx) ([]Utxo, error) {
	if tx == nil {
		return nil, fmt.Errorf("IngesGetCloseTxostCloseTx: nil tx")
	}
	txid := tx.TxSha()
	// double check -- does this tx actually close the channel?
	if !(len(tx.TxIn) == 1 && OutPointsEqual(tx.TxIn[0].PreviousOutPoint, q.Op)) {
		return nil, fmt.Errorf("tx %s doesn't spend channel outpoint %s",
			txid.String(), q.Op.String())
	}
	// hardcode here now... need to save to qchan struct I guess
	q.TimeOut = 5

	// first, check if cooperative
	txIdx := GetStateIdxFromTx(tx)
	if txIdx == 0 || len(tx.TxOut) != 2 {
		// must have been cooperative, or something else we don't recognize
		// nothing spendable, so we're done
		return nil, nil
	}
	var shIdx, pkhIdx uint32
	cTxos := make([]Utxo, 1)
	// still here, so not cooperative. sort outputs into PKH and SH
	if len(tx.TxOut[0].PkScript) == 34 {
		shIdx = 0
		pkhIdx = 1
	} else {
		pkhIdx = 0
		shIdx = 1
	}
	// make sure PKH output is actually PKH
	if len(tx.TxOut[pkhIdx].PkScript) != 22 {
		return nil, fmt.Errorf("non-p2wsh output is length %d, expect 22",
			len(tx.TxOut[pkhIdx].PkScript))
	}

	// next, check if PKH is mine
	if !bytes.Equal(
		tx.TxOut[pkhIdx].PkScript[2:22], btcutil.Hash160(q.MyRefundPub[:])) {
		// ------------pkh not mine; sh is mine
		// note that this doesn't actually check that the SH script is correct.
		// could add that in to double check.

		var shTxo Utxo // create new utxo and copy into it
		shTxo.Op.Hash = txid
		shTxo.Op.Index = shIdx
		shTxo.AtHeight = q.CloseData.CloseHeight
		shTxo.KeyIdx = q.KeyIdx
		shTxo.FromPeer = q.PeerIdx
		shTxo.Value = tx.TxOut[shIdx].Value
		shTxo.SpendableBy = q.CloseData.CloseHeight + int32(q.TimeOut)
		cTxos[0] = shTxo
		// if SH is mine we're done
		return cTxos, nil
	}
	// ----------pkh is mine
	var pkhTxo Utxo // create new utxo and copy into it
	pkhTxo.Op.Hash = txid
	pkhTxo.Op.Index = pkhIdx
	pkhTxo.AtHeight = q.CloseData.CloseHeight
	pkhTxo.KeyIdx = q.KeyIdx
	pkhTxo.FromPeer = q.PeerIdx
	pkhTxo.Value = tx.TxOut[pkhIdx].Value
	pkhTxo.SpendableBy = 1 // 1 for witness, non time locked
	cTxos[0] = pkhTxo

	// OK, it's my PKH, but can I grab the SH???
	if txIdx < q.State.StateIdx {
		// invalid previous state, can be grabbed!
		var shTxo Utxo // create new utxo and copy into it
		shTxo.Op.Hash = txid
		shTxo.Op.Index = shIdx
		shTxo.AtHeight = q.CloseData.CloseHeight
		// note that these key indexes are not sufficient to grab;
		// the grabbable utxo is more of an indicator; the HAKD will need
		// to be loaded from the DB to grab.
		shTxo.KeyIdx = q.KeyIdx
		shTxo.FromPeer = q.PeerIdx
		shTxo.Value = tx.TxOut[shIdx].Value
		shTxo.SpendableBy = -1
		cTxos = append(cTxos, shTxo)
	}

	//	if txIdx > q.State.StateIdx {
	// invalid FUTURE state.  Is this even an error..?
	// don't error for now.  can't do anything anyway.
	//	}

	return cTxos, nil
}

// ChannelInfo prints info about a channel.
func (t *TxStore) QchanInfo(q *Qchan) error {
	// display txid instead of outpoint because easier to copy/paste
	fmt.Printf("CHANNEL %s h:%d (%d,%d) cap: %d\n",
		q.Op.Hash.String(), q.AtHeight, q.PeerIdx, q.KeyIdx, q.Value)
	fmt.Printf("\tPUB mine:%x them:%x REFUND mine:%x them:%x\n",
		q.MyPub[:4], q.TheirPub[:4], q.MyRefundPub[:4], q.TheirRefundPub[:4])
	if q.State == nil || q.ElkRcv == nil {
		fmt.Printf("\t no valid state or elkrem\n")
	} else {

		fmt.Printf("\ta %d (them %d) state index %d\n",
			q.State.MyAmt, q.Value-q.State.MyAmt, q.State.StateIdx)
		fmt.Printf("\tdelta:%d HAKD:%x prevHAKD:%x elk@ %d\n",
			q.State.Delta, q.State.MyHAKDPub[:4], q.State.MyPrevHAKDPub[:4],
			q.ElkRcv.UpTo())
	}

	if !q.CloseData.Closed { // still open, finish here
		return nil
	}

	fmt.Printf("\tCLOSED at height %d by tx: %s\n",
		q.CloseData.CloseHeight, q.CloseData.CloseTxid.String())
	clTx, err := t.GetTx(&q.CloseData.CloseTxid)
	if err != nil {
		return err
	}
	ctxos, err := q.GetCloseTxos(clTx)
	if err != nil {
		return err
	}

	if len(ctxos) == 0 {
		fmt.Printf("\tcooperative close.\n")
		return nil
	}

	fmt.Printf("\tClose resulted in %d spendable txos\n", len(ctxos))
	if len(ctxos) == 2 {
		fmt.Printf("\t\tINVALID CLOSE!!!11\n")
	}
	for i, u := range ctxos {
		fmt.Printf("\t\t%d) amt: %d spendable: %d\n", i, u.Value, u.SpendableBy)
	}
	return nil
}

// RemedyTx produces the "remedy" transaction to get all the money if they
// broadcast an old state which they invalidated.
// This function assumes a recovery is possible; if it can't construct the right
// keys and scripts it will return an error.
func (t *TxStore) RemedyTx(q *Qchan, destTxOut *wire.TxOut) (*wire.MsgTx, error) {
	// load spending tx
	spendTx, err := t.GetTx(&q.CloseData.CloseTxid)
	if err != nil {
		return nil, err
	}
	if len(spendTx.TxOut) != 2 { // (could be more later; onehop is 2)
		return nil, fmt.Errorf("spend tx has %d outputs, can't sweep",
			len(spendTx.TxOut))
	}
	if len(spendTx.TxOut[0].PkScript) < 22 ||
		len(spendTx.TxOut[1].PkScript) < 22 {
		return nil, fmt.Errorf("spend tx has pkscript lengths %d, %d",
			len(spendTx.TxOut[0].PkScript), len(spendTx.TxOut[1].PkScript))
	}
	// find state index based on tx hints (locktime / sequence)
	txIdx := GetStateIdxFromTx(spendTx)
	if txIdx == 0 {
		return nil, fmt.Errorf("no hint, can't recover")
	}
	var grabbableN int
	// figure out which output is the grabbable one
	if bytes.Equal(spendTx.TxOut[0].PkScript[2:22],
		btcutil.Hash160(q.TheirRefundPub[:])) {
		grabbableN = 0
	} else {
		grabbableN = 1
	}
	shOut := spendTx.TxOut[grabbableN]

	// if hinted state is greater than elkrem state we can't recover
	if txIdx > q.ElkRcv.UpTo() {
		return nil, fmt.Errorf("tx at state %d but elkrem only goes to %d",
			txIdx, q.ElkRcv.UpTo())
	}

	// delay will be a channel-wide variable later.
	delay := uint32(5)
	var preScript []byte
	// build shOut script

	elk, err := q.ElkRcv.AtIndex(txIdx)
	if err != nil {
		return nil, err
	}

	// get private signing key
	priv := new(btcec.PrivateKey)
	// get private signing key
	if q.KeyIdx&1 == 0 { //local, use ckdn
		priv = t.GetChanPrivkey(t.IdPub(), q.PeerId, q.ChannelNonce)
	} else { // remote
		priv = t.GetChanPrivkey(q.PeerId, t.IdPub(), q.ChannelNonce)
	}

	// modify private key
	PrivKeyAddBytes(priv, elk.Bytes())

	// serialize pubkey part for script generation
	var HAKDpubArr [33]byte
	copy(HAKDpubArr[:], priv.PubKey().SerializeCompressed())

	// now that everything is chosen, build fancy script and pkh script
	preScript, _ = CommitScript2(HAKDpubArr, q.TheirPub, delay)
	fancyScript := P2WSHify(preScript) // p2wsh-ify
	fmt.Printf("prescript: %x\np2wshd: %x\n", preScript, fancyScript)
	if !bytes.Equal(fancyScript, shOut.PkScript) {
		return nil, fmt.Errorf("script hash mismatch, generated %x expect %x",
			fancyScript, shOut.PkScript)
	}

	// build tx and sign.
	sweepTx := wire.NewMsgTx()
	destTxOut.Value = shOut.Value - 5000 // fixed fee for now
	sweepTx.AddTxOut(destTxOut)

	// add unsigned input
	grabOp := wire.NewOutPoint(&q.CloseData.CloseTxid, uint32(grabbableN))
	sweepIn := wire.NewTxIn(grabOp, nil, nil)
	sweepTx.AddTxIn(sweepIn)

	// make hash cache for this tx
	hCache := txscript.NewTxSigHashes(sweepTx)

	// sign
	sig, err := txscript.RawTxInWitnessSignature(
		sweepTx, hCache, 0, shOut.Value, preScript, txscript.SigHashAll, priv)

	sweepTx.TxIn[0].Witness = make([][]byte, 2)
	sweepTx.TxIn[0].Witness[0] = sig
	sweepTx.TxIn[0].Witness[1] = preScript
	// that's it...?

	return sweepTx, nil
}

// MakeHAKDPubkey generates the HAKD pubkey to send out or everify sigs.
// leaves channel struct the same; returns HAKD pubkey.
func (q *Qchan) MakeTheirHAKDPubkey() ([33]byte, error) {
	var HAKDpubArr [33]byte

	if q == nil || q.ElkSnd == nil { // can't do anything
		return HAKDpubArr, fmt.Errorf("can't access elkrem")
	}
	// use the elkrem sender at state's index.  not index + 1
	// (you revoke index - 1)
	elk, err := q.ElkSnd.AtIndex(q.State.StateIdx)
	if err != nil {
		return HAKDpubArr, err
	}
	// deserialize their channel pubkey
	HAKDPub, err := btcec.ParsePubKey(q.TheirPub[:], btcec.S256())
	if err != nil {
		return HAKDpubArr, err
	}
	// add your elkrem to the pubkey
	PubKeyAddBytes(HAKDPub, elk.Bytes())

	copy(HAKDpubArr[:], HAKDPub.SerializeCompressed())

	return HAKDpubArr, nil
}

// IngestElkrem takes in an elkrem hash, performing 2 checks:
// that it produces the proper HAKD key, and that it fits into the elkrem tree.
// if both of these are the case it updates the channel state, removing the
// revoked HAKD. If either of these checks fail, and definitely the second one
// fails, I'm pretty sure the channel is not recoverable and needs to be closed.
func (q *Qchan) IngestElkrem(elk *wire.ShaHash) error {
	if elk == nil {
		return fmt.Errorf("IngestElkrem: nil hash")
	}

	// first verify if the elkrem produces the previous HAKD's PUBLIC key.
	// We don't actually use the private key operation here, because we can
	// do the same operation on our pubkey that they did, and we have faith
	// in the mysterious power of abelian group homomorphisms that the private
	// key modification will also work.

	// first verify the elkrem insertion (this only performs checks 1/2 the time, so
	// 1/2 the time it'll work even if the elkrem is invalid, oh well)
	err := q.ElkRcv.AddNext(elk)
	if err != nil {
		return err
	}
	fmt.Printf("ingested hash, receiver now has up to %d\n", q.ElkRcv.UpTo())

	// if this is state 1, this is elkrem 0 and we can stop here.
	// there's nothing to revoke. (state 0, also? but that would imply
	// elkrem -1 which isn't a thing... so fail in that case.)
	if q.State.StateIdx == 1 {
		return nil
	}

	// make my channel pubkey array into a pubkey
	derivedPub, err := btcec.ParsePubKey(q.MyPub[:], btcec.S256())
	if err != nil {
		return err
	}

	// add elkrem to my pubkey
	PubKeyAddBytes(derivedPub, elk.Bytes())

	// re-serialize to compare
	var derivedArr, empty [33]byte
	copy(derivedArr[:], derivedPub.SerializeCompressed())

	// see if it matches my previous HAKD pubkey
	if derivedArr != q.State.MyPrevHAKDPub {
		// didn't match, the whole channel is borked.
		return fmt.Errorf("Provided elk doesn't create HAKD pub %x! Need to close",
			q.State.MyPrevHAKDPub)
	}

	// it did match, so we can clear the previous HAKD pub
	q.State.MyPrevHAKDPub = empty

	return nil
}

// SignBreak signs YOUR tx, which you already have a sig for
func (t TxStore) SignBreakTx(q *Qchan) (*wire.MsgTx, error) {
	// generate their HAKDpub.  Be sure you haven't revoked it!
	theirHAKDpub, err := q.MakeTheirHAKDPubkey()
	if err != nil {
		return nil, err
	}

	tx, err := q.BuildStateTx(theirHAKDpub)
	if err != nil {
		return nil, err
	}

	// make hash cache for this tx
	hCache := txscript.NewTxSigHashes(tx)

	// generate script preimage (keep track of key order)
	pre, swap, err := FundTxScript(q.MyPub[:], q.TheirPub[:])
	if err != nil {
		return nil, err
	}

	// get private signing key
	priv := new(btcec.PrivateKey)
	// get private signing key
	if q.KeyIdx&1 == 0 { //local, use ckdn
		priv = t.GetChanPrivkey(t.IdPub(), q.PeerId, q.ChannelNonce)
	} else { // remote
		priv = t.GetChanPrivkey(q.PeerId, t.IdPub(), q.ChannelNonce)
	}

	// generate sig.
	mySig, err := txscript.RawTxInWitnessSignature(
		tx, hCache, 0, q.Value, pre, txscript.SigHashAll, priv)

	// put the sighash all byte on the end of their signature
	// copy here because... otherwise I get unexpected fault address 0x...
	theirSig := make([]byte, len(q.State.sig)+1)
	copy(theirSig, q.State.sig)
	theirSig[len(theirSig)-1] = byte(txscript.SigHashAll)

	fmt.Printf("made mysig: %x theirsig: %x\n", mySig, theirSig)
	// add sigs to the witness stack
	if swap {
		tx.TxIn[0].Witness = SpendMultiSigWitStack(pre, theirSig, mySig)
	} else {
		tx.TxIn[0].Witness = SpendMultiSigWitStack(pre, mySig, theirSig)
	}
	return tx, nil
}

// SignNextState generates your signature for their state. (usually)
func (t TxStore) SignState(q *Qchan) ([]byte, error) {
	var empty [33]byte
	// build transaction for next state
	tx, err := q.BuildStateTx(empty) // generally their tx, as I'm signing
	if err != nil {
		return nil, err
	}

	// make hash cache for this tx
	hCache := txscript.NewTxSigHashes(tx)

	// generate script preimage (ignore key order)
	pre, _, err := FundTxScript(q.MyPub[:], q.TheirPub[:])
	if err != nil {
		return nil, err
	}

	priv := new(btcec.PrivateKey)
	// get private signing key
	if q.KeyIdx&1 == 0 { //local, use ckdn
		priv = t.GetChanPrivkey(t.IdPub(), q.PeerId, q.ChannelNonce)
	} else { // remote
		priv = t.GetChanPrivkey(q.PeerId, t.IdPub(), q.ChannelNonce)
	}

	// generate sig.
	sig, err := txscript.RawTxInWitnessSignature(
		tx, hCache, 0, q.Value, pre, txscript.SigHashAll, priv)
	// truncate sig (last byte is sighash type, always sighashAll)
	sig = sig[:len(sig)-1]

	fmt.Printf("____ sig creation for channel (%d,%d):\n", q.PeerIdx, q.KeyIdx)
	fmt.Printf("\tinput %s\n", tx.TxIn[0].PreviousOutPoint.String())
	fmt.Printf("\toutput 0: %x %d\n", tx.TxOut[0].PkScript, tx.TxOut[0].Value)
	fmt.Printf("\toutput 1: %x %d\n", tx.TxOut[1].PkScript, tx.TxOut[1].Value)
	fmt.Printf("\tstate %d myamt: %d theiramt: %d\n", q.State.StateIdx, q.State.MyAmt, q.Value-q.State.MyAmt)
	fmt.Printf("\tmy HAKD pub: %x their HAKD pub: %x sig: %x\n", q.State.MyHAKDPub[:4], empty[:4], sig)

	return sig, nil
}

// VerifySig verifies their signature for your next state.
// it also saves the sig if it's good.
// do bool, error or just error?  Bad sig is an error I guess.
// for verifying signature, always use theirHAKDpub, so generate & populate within
// this function.
func (q *Qchan) VerifySig(sig []byte) error {
	theirHAKDpub, err := q.MakeTheirHAKDPubkey()
	if err != nil {
		fmt.Printf("ACKSIGHandler err %s", err.Error())
		return err
	}

	// ALWAYS my tx, ALWAYS their HAKD when I'm verifying.
	tx, err := q.BuildStateTx(theirHAKDpub)
	if err != nil {
		return err
	}

	// generate fund output script preimage (ignore key order)
	pre, _, err := FundTxScript(q.MyPub[:], q.TheirPub[:])
	if err != nil {
		return err
	}

	hCache := txscript.NewTxSigHashes(tx)
	// always sighash all
	hash, err := txscript.CalcWitnessSigHash(
		pre, hCache, txscript.SigHashAll, tx, 0, q.Value)
	if err != nil {
		return err
	}

	// sig is pre-truncated; last byte for sighashtype is always sighashAll
	pSig, err := btcec.ParseDERSignature(sig, btcec.S256())
	if err != nil {
		return err
	}
	theirPubKey, err := btcec.ParsePubKey(q.TheirPub[:], btcec.S256())
	if err != nil {
		return err
	}
	fmt.Printf("____ sig verification for channel (%d,%d):\n", q.PeerIdx, q.KeyIdx)
	fmt.Printf("\tinput %s\n", tx.TxIn[0].PreviousOutPoint.String())
	fmt.Printf("\toutput 0: %x %d\n", tx.TxOut[0].PkScript, tx.TxOut[0].Value)
	fmt.Printf("\toutput 1: %x %d\n", tx.TxOut[1].PkScript, tx.TxOut[1].Value)
	fmt.Printf("\tstate %d myamt: %d theiramt: %d\n", q.State.StateIdx, q.State.MyAmt, q.Value-q.State.MyAmt)
	fmt.Printf("\tmy HAKD pub: %x their HAKD pub: %x sig: %x\n", q.State.MyHAKDPub[:4], theirHAKDpub[:4], sig)

	worked := pSig.Verify(hash, theirPubKey)
	if !worked {
		return fmt.Errorf("Their sig was no good!!!!!111")
	}

	// copy signature, overwriting old signature.
	q.State.sig = sig

	return nil
}

// BuildStateTx constructs and returns a state tx.  As simple as I can make it.
// This func just makes the tx with data from State in ram, and HAKD key arg
// Delta should always be 0 when making this tx.
// It decides whether to make THEIR tx or YOUR tx based on the HAKD pubkey given --
// if it's zero, then it makes their transaction (for signing onlu)
// If it's zero, it makes your transaction (for verification in most cases,
// but also for signing when breaking the channel)
// Index is used to set nlocktime for state hints.
// fee and op_csv timeout are currently hardcoded, make those parameters later.
func (q *Qchan) BuildStateTx(theirHAKDpub [33]byte) (*wire.MsgTx, error) {
	// sanity checks
	s := q.State // use it a lot, make shorthand variable
	if s == nil {
		return nil, fmt.Errorf("channel (%d,%d) has no state", q.PeerIdx, q.KeyIdx)
	}
	// if delta is non-zero, something is wrong.
	if s.Delta != 0 {
		return nil, fmt.Errorf(
			"BuildStateTx: delta is %d (expect 0)", s.Delta)
	}

	var empty [33]byte

	var fancyAmt, pkhAmt int64   // output amounts
	var revPub, timePub [33]byte // pubkeys
	var pkhPub [33]byte          // the simple output's pub key hash
	fee := int64(5000)           // fixed fee for now
	delay := uint32(5)           // fixed CSV delay for now
	// delay is super short for testing.

	if theirHAKDpub == empty { // TheirHAKDPub is empty; build THEIR tx (to sign)
		// Their tx that they store.  I get funds unencumbered.
		pkhPub = q.MyRefundPub
		pkhAmt = s.MyAmt - fee

		timePub = q.TheirRefundPub // these are their funds, but they have to wait
		revPub = s.MyHAKDPub       // if they're given me the elkrem, it's mine
		fancyAmt = (q.Value - s.MyAmt) - fee
	} else { // theirHAKDPub is full; build MY tx (to verify) (unless breaking)
		// My tx that I store.  They get funds unencumbered.
		pkhPub = q.TheirRefundPub
		pkhAmt = (q.Value - s.MyAmt) - fee

		timePub = q.MyRefundPub // these are my funds, but I have to wait
		revPub = theirHAKDpub   // I can revoke by giving them the elkrem
		fancyAmt = s.MyAmt - fee
	}

	// now that everything is chosen, build fancy script and pkh script
	fancyScript, _ := CommitScript2(revPub, timePub, delay)
	pkhScript := DirectWPKHScript(pkhPub) // p2wpkh-ify
	fancyScript = P2WSHify(fancyScript)   // p2wsh-ify

	// create txouts by assigning amounts
	outFancy := wire.NewTxOut(fancyAmt, fancyScript)
	outPKH := wire.NewTxOut(pkhAmt, pkhScript)

	// make a new tx
	tx := wire.NewMsgTx()
	// add txouts
	tx.AddTxOut(outFancy)
	tx.AddTxOut(outPKH)
	// add unsigned txin
	tx.AddTxIn(wire.NewTxIn(&q.Op, nil, nil))
	// set index hints
	SetStateIdxBits(tx, s.StateIdx)

	// sort outputs
	txsort.InPlaceSort(tx)
	return tx, nil
}

func DirectWPKHScript(pub [33]byte) []byte {
	builder := txscript.NewScriptBuilder()
	builder.AddOp(txscript.OP_0).AddData(btcutil.Hash160(pub[:]))
	b, _ := builder.Script()
	return b
}

/* old script2, need to push a 1 or 0 to select
builder.AddOp(txscript.OP_IF)
builder.AddInt64(int64(delay))
builder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)
builder.AddOp(txscript.OP_DROP)
builder.AddData(TKey[:])
builder.AddOp(txscript.OP_ELSE)
builder.AddData(RKey[:])
builder.AddOp(txscript.OP_ENDIF)
builder.AddOp(txscript.OP_CHECKSIG)
*/
/* uglier, need dup and drop...
builder.AddOp(txscript.OP_DUP)
builder.AddData(TKey[:])
builder.AddOp(txscript.OP_CHECKSIG)
builder.AddOp(txscript.OP_IF)
builder.AddOp(txscript.OP_DROP)
builder.AddInt64(int64(delay))
builder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)
builder.AddOp(txscript.OP_ELSE)
builder.AddData(RKey[:])
builder.AddOp(txscript.OP_CHECKSIG)
builder.AddOp(txscript.OP_ENDIF)
*/

// CommitScript2 doesn't use hashes, but a modified pubkey.
// To spend from it, push your sig.  If it's time-based,
// you have to set the txin's sequence.
func CommitScript2(RKey, TKey [33]byte, delay uint32) ([]byte, error) {
	builder := txscript.NewScriptBuilder()

	builder.AddOp(txscript.OP_DUP)
	builder.AddData(RKey[:])
	builder.AddOp(txscript.OP_CHECKSIG)

	builder.AddOp(txscript.OP_NOTIF)

	builder.AddData(TKey[:])
	builder.AddOp(txscript.OP_CHECKSIGVERIFY)
	builder.AddInt64(int64(delay))
	builder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)

	builder.AddOp(txscript.OP_ENDIF)

	return builder.Script()
}

// FundMultiOut creates a TxOut for the funding transaction.
// Give it the two pubkeys and it'll give you the p2sh'd txout.
// You don't have to remember the p2sh preimage, as long as you remember the
// pubkeys involved.
func FundTxOut(pubA, puB []byte, amt int64) (*wire.TxOut, error) {
	if amt < 0 {
		return nil, fmt.Errorf("Can't create FundTx script with negative coins")
	}
	scriptBytes, _, err := FundTxScript(pubA, puB)
	if err != nil {
		return nil, err
	}
	scriptBytes = P2WSHify(scriptBytes)

	return wire.NewTxOut(amt, scriptBytes), nil
}

// FundMultiPre generates the non-p2sh'd multisig script for 2 of 2 pubkeys.
// useful for making transactions spending the fundtx.
// returns a bool which is true if swapping occurs.
func FundTxScript(aPub, bPub []byte) ([]byte, bool, error) {
	if len(aPub) != 33 || len(bPub) != 33 {
		return nil, false, fmt.Errorf("Pubkey size error. Compressed pubkeys only")
	}
	var swapped bool
	if bytes.Compare(aPub, bPub) == -1 { // swap to sort pubkeys if needed
		aPub, bPub = bPub, aPub
		swapped = true
	}
	bldr := txscript.NewScriptBuilder()
	// Require 1 signatures, either key// so from both of the pubkeys
	bldr.AddOp(txscript.OP_2)
	// add both pubkeys (sorted)
	bldr.AddData(aPub)
	bldr.AddData(bPub)
	// 2 keys total.  In case that wasn't obvious.
	bldr.AddOp(txscript.OP_2)
	// Good ol OP_CHECKMULTISIG.  Don't forget the zero!
	bldr.AddOp(txscript.OP_CHECKMULTISIG)
	// get byte slice
	pre, err := bldr.Script()
	return pre, swapped, err
}

// the scriptsig to put on a P2SH input.  Sigs need to be in order!
func SpendMultiSigWitStack(pre, sigA, sigB []byte) [][]byte {

	witStack := make([][]byte, 4)

	witStack[0] = nil // it's not an OP_0 !!!! argh!
	witStack[1] = sigA
	witStack[2] = sigB
	witStack[3] = pre

	return witStack
}

func P2WSHify(scriptBytes []byte) []byte {
	bldr := txscript.NewScriptBuilder()
	bldr.AddOp(txscript.OP_0)
	wsh := fastsha256.Sum256(scriptBytes)
	bldr.AddData(wsh[:])
	b, _ := bldr.Script() // ignore script errors
	return b
}

/*----- serialization for StatCom ------- */
/*
bytes   desc   ends at
1	len			1
8	StateIdx		9
8	MyAmt		17
4	Delta		21
33	MyRev		54
33	MyPrevRev	87
70?	Sig			157
... to 131 bytes, ish.

note that sigs are truncated and don't have the sighash type byte at the end.

their rev hash can be derived from the elkrem sender
and the stateidx.  hash160(elkremsend(sIdx)[:16])

*/

// ToBytes turns a StatCom into 106ish bytes
func (s *StatCom) ToBytes() ([]byte, error) {
	var buf bytes.Buffer
	var err error

	// write 8 byte state index
	err = binary.Write(&buf, binary.BigEndian, s.StateIdx)
	if err != nil {
		return nil, err
	}
	// write 8 byte amount of my allocation in the channel
	err = binary.Write(&buf, binary.BigEndian, s.MyAmt)
	if err != nil {
		return nil, err
	}
	// write 4 byte delta.  At steady state it's 0.
	err = binary.Write(&buf, binary.BigEndian, s.Delta)
	if err != nil {
		return nil, err
	}
	// write 33 byte my revocation pubkey
	_, err = buf.Write(s.MyHAKDPub[:])
	if err != nil {
		return nil, err
	}
	// write 33 byte my previous revocation hash
	// at steady state it's 0s.
	_, err = buf.Write(s.MyPrevHAKDPub[:])
	if err != nil {
		return nil, err
	}
	// write their sig
	_, err = buf.Write(s.sig)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// StatComFromBytes turns 160 ish bytes into a StatCom
// it might be only 86 bytes because there is no sig (first save)
func StatComFromBytes(b []byte) (*StatCom, error) {
	var s StatCom
	if len(b) < 80 || len(b) > 170 {
		return nil, fmt.Errorf("StatComFromBytes got %d bytes, expect around 131\n",
			len(b))
	}
	buf := bytes.NewBuffer(b)
	// read 8 byte state index
	err := binary.Read(buf, binary.BigEndian, &s.StateIdx)
	if err != nil {
		return nil, err
	}
	// read 8 byte amount of my allocation in the channel
	err = binary.Read(buf, binary.BigEndian, &s.MyAmt)
	if err != nil {
		return nil, err
	}
	// read 4 byte delta.
	err = binary.Read(buf, binary.BigEndian, &s.Delta)
	if err != nil {
		return nil, err
	}
	// read 33 byte HAKD pubkey
	copy(s.MyHAKDPub[:], buf.Next(33))
	// read 33 byte previous HAKD pubkey
	copy(s.MyPrevHAKDPub[:], buf.Next(33))
	// the rest is their sig
	s.sig = buf.Bytes()

	return &s, nil
}

/*----- serialization for QChannels ------- */

/* Qchan serialization:
bytes   desc   at offset

60	utxo		0
20	nonce	60
33	thrref	80

length 113

peeridx is inferred from position in db.
*/
//TODO !!! don't store the outpoint!  it's redundant!!!!!
// it's just a nonce and a refund, that's it! 40 bytes!

func (q *Qchan) ToBytes() ([]byte, error) {
	var buf bytes.Buffer
	// first serialize the utxo part
	uBytes, err := q.Utxo.ToBytes()
	if err != nil {
		return nil, err
	}
	// write that into the buffer first
	_, err = buf.Write(uBytes)
	if err != nil {
		return nil, err
	}
	// write 20 byte channel nonce
	_, err = buf.Write(q.ChannelNonce[:])
	if err != nil {
		return nil, err
	}

	// write their refund pubkey
	_, err = buf.Write(q.TheirRefundPub[:])
	if err != nil {
		return nil, err
	}
	// closing txid goes in a different bucket.
	// (this is mostly 00 so kindof a waste to serialize here...
	//	_, err = buf.Write(q.CloseTXO.)
	//	if err != nil {
	//		return nil, err
	//	}

	// done
	return buf.Bytes(), nil
}

// QchanFromBytes turns bytes into a Qchan.
// the first 60 bytes are the utxo, then next 33 is the pubkey, then their pkh.
// then finally txid of spending transaction
func QchanFromBytes(b []byte) (Qchan, error) {
	var q Qchan

	if len(b) < 113 {
		return q, fmt.Errorf("Got %d bytes for qchan, expect 105", len(b))
	}

	u, err := UtxoFromBytes(b[:60])
	if err != nil {
		return q, err
	}

	q.Utxo = u // assign the utxo

	copy(q.ChannelNonce[:], b[60:80])
	if err != nil {
		return q, err
	}
	copy(q.TheirRefundPub[:], b[80:])

	return q, nil
}

/*----- serialization for CloseTXOs -------

  serialization:
closetxid	32
closeheight	4

only closeTxid needed, I think

*/

func (c *QCloseData) ToBytes() ([]byte, error) {
	if c == nil {
		return nil, fmt.Errorf("nil qclose")
	}
	b := make([]byte, 36)
	copy(b[:32], c.CloseTxid.Bytes())
	copy(b[32:], I32tB(c.CloseHeight))
	return b, nil
}

// QCloseFromBytes deserializes a Qclose.  Note that a nil slice
// gives an empty / non closed qclose.
func QCloseFromBytes(b []byte) (QCloseData, error) {
	var c QCloseData
	if len(b) == 0 { // empty is OK
		return c, nil

	}
	if len(b) < 36 {
		return c, fmt.Errorf("close data %d bytes, expect 36", len(b))
	}
	var empty wire.ShaHash
	c.CloseTxid.SetBytes(b[:32])
	if !c.CloseTxid.IsEqual(&empty) {
		c.Closed = true
	}
	c.CloseHeight = BtI32(b[32:36])

	return c, nil
}

//type Qclosetxo struct {
//type Qclosetxo struct {
//	// closed is true if channel closing tx has been seen & stored.
//	// basically true of Op.hash != 0.  not stored.
//	Closed bool
//	// your outpoint, either pkh or script.  If cooperative it's just txid:0
//	Op     wire.OutPoint
//	Height int32 // 0 when unconfirmed; height of closing tx.

//	// true means you can spend it!  False means you can't, either because
//	// it's coop, or because you already spent it.
//	Unspent   bool
//	SpendTxid wire.ShaHash

//	// true means you can grab it and haven't yet!  do it now!
//	Ungrabbed bool
//	GrabTxid  wire.ShaHash
